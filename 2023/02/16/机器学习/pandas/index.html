<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Hexo</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1></h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-02-15T22:51:24.954Z" id="date"> 2023-02-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-02-15T22:50:21.500Z" id="updated"> 2023-02-16</time></div></span></div></div><hr><div id="post-content"><p>创建Series</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import pandas as pd <br>s = pd.Series([&#x27;banana&#x27;,42])<br></code></pre></td></tr></table></figure>
<p>创建DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">name_list = pd.DataFrame(<br>	&#123;<br>		&#x27;Name&#x27;:[&#x27;Tome&#x27;,&#x27;Bob&#x27;], <br>		&#x27;Occupation&#x27;:[&#x27;Teacher&#x27;,&#x27;IT Engineer&#x27;], <br>		&#x27;age&#x27;:[28,36]<br>	&#125;<br>)<br></code></pre></td></tr></table></figure>
<h1 id="Series-常用操作"><a href="#Series-常用操作" class="headerlink" title="Series 常用操作"></a>Series 常用操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">loc	使用索引值取子集<br>iloc 	使用索引位置取子集<br>dtype或dtypes Series	内容的类型<br>T 	Series的转置矩阵<br>shape 	数据的维数<br>size 	Series中元素的数量<br>values 	Series的值<br>.value_counts()		统计value数量<br>director.count() 	返回非空值<br>describe() 	打印描述信息<br></code></pre></td></tr></table></figure>
<h1 id="Series的一些方法"><a href="#Series的一些方法" class="headerlink" title="Series的一些方法"></a>Series的一些方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">方法 	说明<br>append 	连接两个或多个Series<br>corr 	计算与另一个Series的相关系数<br>cov	 计算与另一个Series的协方差<br>describe 计算常见统计量<br>drop_duplicates 	返回去重之后的Series<br>equals 		判断两个Series是否相同<br>get_values 	获取Series的值，作用与values属性相同<br>hist 	绘制直方图<br>isin Series	中是否包含某些值<br>min 	返回最小值<br>max	返回最大值<br>mean	返回算术平均值<br>median	返回中位数<br>mode 	返回众数<br>quantile 	返回指定位置的分位数<br>replace 	用指定值代替Series中的值<br>sample	 返回Series的随机采样值<br>sort_values 	对值进行排序<br>to_frame	把Series转换为DataFrame<br>unique 		去重返回数组<br></code></pre></td></tr></table></figure>
<p>两个Series之间计算，如果Series元素个数相同，则将两个Series对应元素进行计算；元素不同则缺失用NaN表示</p>
<h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ndim 查看数集的维度<br>set_index 修改索引<br>drop 删除列<br>to_pickle 保存<br>read_pickle 读取<br>to_csv  保存成csv文件<br>格式：(&#x27;output/scientists_df.tsv&#x27;,sep=&#x27;\t&#x27;)<br><br><br><br>to_clipboard 把数据保存到系统剪贴板，方便粘贴<br>to_dict 把数据转换成Python字典<br>to_hdf 把数据保存为HDF格式<br>to_html 把数据转换成HTML<br>to_json 把数据转换成JSON字符串<br>to_sql 把数据保存到SQL数据库<br><br>nlargest(100,&#x27;imdb_score&#x27;)<br><br>0.1<br>统计数值列，并进行转置<br>college.describe().T<br><br>统计多方式数值<br>.describe()<br><br>nlargest方法显示出某列的排序<br>nlargest(100,&#x27;imdb_score&#x27;).head()<br><br>传入一个字典<br>agg(&#x27;key&#x27;:&#x27;value&#x27;)<br></code></pre></td></tr></table></figure>
<h1 id="聚合重点"><a href="#聚合重点" class="headerlink" title="聚合重点"></a>聚合重点</h1><p>agg</p>
<h1 id="数据链接"><a href="#数据链接" class="headerlink" title="数据链接"></a>数据链接</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">concat	把dataframe(简单叠堆)<br>ignore_index = True	忽略后面DataFrame的索引<br><br>添加列（默认添加行）<br>，传入参数 axis = columns<br>col_concat = pd.concat([df1,df2,df3],axis=1)<br><br>向DataFrame添加一列，不需要调用函数，通过dataframe[&#x27;列名&#x27;] = [&#x27;值&#x27;] 即可<br><br></code></pre></td></tr></table></figure>
<h1 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h1><p>pd.read_sql_table<br>从数据库中读取表，第一个参数是表名，第二个参数是数据库连接对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">how = ’left‘ 对应SQL中的 left outer 保留左侧表中的所有key<br>how = ’right‘ 对应SQL中的 right outer 保留右侧表中的所有key<br>how = &#x27;outer&#x27; 对应SQL中的 full outer 保留左右两侧侧表中的所有key<br>how = &#x27;inner&#x27; 对应SQL中的 inner 只保留左右两侧都有的key<br><br>转换：<br>to_timedelta 将Milliseconds列转变为timedelta数据类型<br>dt.floor(&#x27;s&#x27;) dt.floor() 时间类型数据，按指定单位截断数据<br><br>DataFrame的assign方法：创建新列<br>.assign<br><br>join合并，依据两个DataFrame的行索引，如果合并的两个数据有相同的列名，需要通过lsuffix，和rsuffix，指定合并后的列名<br>的前缀<br>stocks_2016.join(stocks_2017, lsuffix=&#x27;_2016&#x27;, rsuffix=&#x27;_2017&#x27;, how=&#x27;outer&#x27;)<br><br>concat, join, 和merge的区别<br><br>concat ：<br>Pandas函数<br>可以垂直和水平地连接两个或多个pandas对象<br>只用索引对齐<br>默认是外连接（也可以设为内连接）<br>join ：<br>DataFrame方法<br>只能水平连接两个或多个pandas对象<br>对齐是靠被调用的DataFrame的列索引或行索引和另一个对象的行索引（不能是列索引）<br>通过笛卡尔积处理重复的索引值<br>默认是左连接（也可以设为内连接、外连接和右连接）<br>merge ：<br>DataFrame方法<br>只能水平连接两个DataFrame对象<br>对齐是靠被调用的DataFrame的列或行索引和另一个DataFrame的列或行索引<br>通过笛卡尔积处理重复的索引值<br>默认是内连接（也可以设为左连接、外连接、右连接）<br></code></pre></td></tr></table></figure>

<h1 id="缺失数据处理"><a href="#缺失数据处理" class="headerlink" title="缺失数据处理"></a>缺失数据处理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">keep_default_na = False 关闭NaN显示<br>ffill 填充，用时间序列中空值的上一个非空值填充<br>city_day.fillna(method=&#x27;ffill&#x27;,inplace=True) city_day[&#x27;Xylene&#x27;][50:65]<br>用时间序列中空值的下一个非空值填充<br>method=&#x27;bfill&#x27;<br>线性差值方法<br>limit_direction=&quot;both&quot;<br></code></pre></td></tr></table></figure>
<h1 id="整理数据"><a href="#整理数据" class="headerlink" title="整理数据"></a>整理数据</h1><p>melt<br>既可以用pd.melt, 也可使用dataframe.melt()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">frame dataframe 被 melt 的数据集名称在 pd.melt() 中使用<br>id_vars tuple/list/ndarray 	可选项不需要被转换的列名，在转换后作为标识符列（不是索引列）<br>value_vars tuple/list/ndarray 	可选项需要被转换的现有列如果未指明，除 id_vars 之外的其他列都被转换<br>var_name string variable 	默认值自定义列名名称设置由 &#x27;value_vars&#x27; 组成的新的 column name<br>value_name string value 	默认值自定义列名名称设置由 &#x27;value_vars&#x27; 的数据组成的新的 column name<br>col_level int/string 	可选项如果列是MultiIndex，则使用此级别<br><br>数据整理（函数自动处理）<br>pew_long = pd.melt(pew,id_vars=&#x27;religion&#x27;)<br>pew_long<br></code></pre></td></tr></table></figure>
<h1 id="处理查询冗余"><a href="#处理查询冗余" class="headerlink" title="处理查询冗余"></a>处理查询冗余</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">对于同一首歌曲来说，歌曲信息是完全一样的，可以考虑单独保存歌曲信息<br>减少上表中保存的歌曲信息，可以节省存储空间，需要完整信息的时候，可以通过merge拼接数据<br>我们可以把year,artist,track,time和date.entered放入一个新的dataframe中<br><br>1.提取表信息，进行去重<br>illboard_songs = bill_borad_long[[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]] billboard_songs = billboard_songs.drop_duplicates()<br>billboard_songs<br><br>2.为新拆分处理出来的数据添加ID列（添加ID）<br>billboard_songs[&#x27;id&#x27;] = range(len(billboard_songs)) <br>billboard_songs<br><br>3.数据拆分成两个dataframe：billboard_songs和 billboard_ratings<br>取出每周评分，去掉冗余部分<br>billboard_ratings = bill_borad_long.merge(billboard_songs,on=[&#x27;year&#x27;,&#x27;artist&#x27;,&#x27;track&#x27;,&#x27;time&#x27;,&#x27;date.entered&#x27;]) billboard_ratings = billboard_ratings[[&#x27;id&#x27;,&#x27;week&#x27;,&#x27;rating&#x27;]] billboard_ratings<br><br>4.用merage还原数据<br>billboard_songs.merge(billboard_ratings,on=[&#x27;id&#x27;])<br><br></code></pre></td></tr></table></figure>
<h1 id="stack整理数据"><a href="#stack整理数据" class="headerlink" title="stack整理数据"></a>stack整理数据</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">用rename_axis给不同的行索引层级命名<br>reset_index()，将结果变为DataFrame<br></code></pre></td></tr></table></figure>
<h1 id="wide-to-long整理数据"><a href="#wide-to-long整理数据" class="headerlink" title="wide_to_long整理数据"></a>wide_to_long整理数据</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stubs = [&#x27;actor&#x27;, &#x27;actor_facebook_likes&#x27;]<br>actor2_tidy = pd.wide_to_long(actor2, stubnames=stubs, i=[&#x27;movie_title&#x27;], j=&#x27;actor_num&#x27;, sep=&#x27;_&#x27;).reset_index() <br>actor2_tidy.head()<br></code></pre></td></tr></table></figure>
<h1 id="unstack-处理数据"><a href="#unstack-处理数据" class="headerlink" title="unstack 处理数据"></a>unstack 处理数据</h1><p>之前介绍了stack，unstack可以将stack的结果恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">state_fruit.stack().unstack()<br></code></pre></td></tr></table></figure>


<h1 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h1><p>.apply(方法名)</p>
<h1 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def avg_2_mod(x,y):<br> 	if(x==20): <br>		return (np.NaN) <br>	else:return (x+y)/2 <br>avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])<br>上面函数中, x==20 , x 是向量, 但20是标量, 不能直接计算. 这个时候可以使用np.vectorize将函数向量化<br>使用装饰器<br>@np.vectorize <br>def vec_avg_2_mod(x,y): <br>	if(x==20):<br>		 return (np.NaN) <br>	else:<br>		return (x+y)/2 <br>vec_avg_2_mod(df[&#x27;a&#x27;],df[&#x27;b&#x27;])<br></code></pre></td></tr></table></figure>
<h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">df.apply(lambda x: x+1)<br></code></pre></td></tr></table></figure>
<h1 id="Pandas内置的聚合方法"><a href="#Pandas内置的聚合方法" class="headerlink" title="Pandas内置的聚合方法"></a>Pandas内置的聚合方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Pandas	方法 Numpy函数 说明<br>count 	np.count_nonzero 	频率统计(不包含NaN值)<br>size 	频率统计(包含NaN值)<br>mean np.mean 	求平均值<br>std np.std 	标准差<br>min np.min 	最小值<br>quantile() 	np.percentile() 	分位数<br>max np.max 	求最大值<br>sum np.sum 	求和<br>var np.var 	方差<br>describe 	计数、平均值、标准差，最小值、分位数、最大值<br>first 	返回第一行<br>last 	返回最后一行<br>nth 返回第N行(Python从0开始计数)<br></code></pre></td></tr></table></figure>
<p>agg<br>agg.(‘列名’:’方法名’).rename(‘原名’：’新名’)</p>
<h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>transform 转换，需要把DataFrame中的值传递给一个函数， 而后由该函数”转换”数据。<br>aggregate(聚合) 返回单个聚合值，但transform 不会减少数据量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 计算z-score x - 平均值/标准差 <br>def my_zscore(x): <br>	return (x-x.mean())/x.std()<br> #按年分组 计算z-score <br>df.groupby(&#x27;year&#x27;).lifeExp.transform(my_zscore)<br></code></pre></td></tr></table></figure>
<h1 id="transform分组填充缺失值"><a href="#transform分组填充缺失值" class="headerlink" title="transform分组填充缺失值"></a>transform分组填充缺失值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">之前介绍了填充缺失值的各种方法，对于某些数据集，可以使用列的平均值来填充缺失值。某些情况下，可以考虑将列进行分组，分<br>组之后取平均再填充缺失值<br>tips_10 = pd.read_csv(&#x27;data/tips.csv&#x27;).sample(10,random_state = 42) <br>tips_10<br><br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/02/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">← Next </a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/02/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Numpy/"> Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Series-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Series 常用操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Series%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Series的一些方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DataFrame"><span class="toc-number">3.</span> <span class="toc-text">DataFrame</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E9%87%8D%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">聚合重点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">数据链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">链接数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">缺失数据处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">8.</span> <span class="toc-text">整理数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E5%86%97%E4%BD%99"><span class="toc-number">9.</span> <span class="toc-text">处理查询冗余</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack%E6%95%B4%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">10.</span> <span class="toc-text">stack整理数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wide-to-long%E6%95%B4%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">11.</span> <span class="toc-text">wide_to_long整理数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unstack-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">12.</span> <span class="toc-text">unstack 处理数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">自定义方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">向量函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">lambda函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pandas%E5%86%85%E7%BD%AE%E7%9A%84%E8%81%9A%E5%90%88%E6%96%B9%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">Pandas内置的聚合方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2"><span class="toc-number">17.</span> <span class="toc-text">转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#transform%E5%88%86%E7%BB%84%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-number">18.</span> <span class="toc-text">transform分组填充缺失值</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();}</script><script src="/js/arknights.js"></script><script src="/js/pjax.js"></script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>